{"version":3,"sources":["solve.ts","Board.tsx","ModeSelect.tsx","App.tsx","index.tsx"],"names":["initialConfig","x","y","targetConfig","factors","res","i","push","configHasher","config","hashCode","arrange","map","coordinate","forEach","val","index","lessValCnt","length","isConfigEql","c1","c2","directions","getNextMove","nextMove","dir","nx","ny","newConfig","estimateCost","target","Math","abs","solveFns","bfs","a","begTime","Date","getTime","solution","solutionVisitSet","std","HashSet","preSolution","HashMap","solutionQueue","Queue","solved","empty","front","pop","count","first","second","time","curConfig","find","dfs","Array","of","innerDfs","bestfs","sort","b","bab","PriorityQueue","f","initialConfigWithVal","g","top","newConfigWithVal","tileSize","Board","boardAnimInterval","boardConfig","className","style","undefined","ModeSelect","mode","onModeChange","onChange","radioInfo","type","checked","name","value","id","htmlFor","App","props","useState","setSolution","setMode","NaN","timeCost","setTimeCost","msg","setMsg","setBoardConfig","useEffect","configIndex","interval","setInterval","clearInterval","useBoardAnim","onClick","e","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.257ee112.chunk.js","sourcesContent":["import type { BoardConfig, Mode, SolutionPath, SolveFn } from \"./types\";\nimport std from \"tstl\";\n\nexport const initialConfig: BoardConfig = [\n  { x: 2, y: 2 },\n  { x: 1, y: 0 },\n  { x: 0, y: 0 },\n  { x: 0, y: 2 },\n  { x: 2, y: 1 },\n  { x: 2, y: 0 },\n  { x: 1, y: 2 },\n  { x: 1, y: 1 },\n  { x: 0, y: 1 },\n];\n\nexport const targetConfig: BoardConfig = [\n  { x: 2, y: 2 },\n  { x: 0, y: 0 },\n  { x: 0, y: 1 },\n  { x: 0, y: 2 },\n  { x: 1, y: 0 },\n  { x: 1, y: 1 },\n  { x: 1, y: 2 },\n  { x: 2, y: 0 },\n  { x: 2, y: 1 },\n];\n\nconst factors = (() => {\n  const res = [1];\n  for (let i = 1; i < 9; ++i) {\n    res.push(res[i - 1] * i);\n  }\n  return res;\n})();\n\nfunction configHasher(config: BoardConfig): number {\n  let hashCode = 0;\n  const arrange: number[] = config.map((coordinate) => coordinate.x * 3 + coordinate.y);\n  arrange.forEach((val, index) => {\n    let lessValCnt = 0;\n    for (let i = index + 1; i < arrange.length; ++i) {\n      if (arrange[i] < arrange[index]) {\n        lessValCnt++;\n      }\n    }\n    hashCode += lessValCnt * factors[arrange.length - 1 - index];\n  });\n  return hashCode;\n}\n\nfunction isConfigEql(c1: BoardConfig, c2: BoardConfig): boolean {\n  for (let i = 0; i < c1.length; ++i) {\n    if (c1[i].x !== c2[i].x || c1[i].y !== c2[i].y) {\n      return false;\n    }\n  }\n  return true;\n}\n\nconst directions = [\n  [0, 1],\n  [0, -1],\n  [1, 0],\n  [-1, 0],\n];\n\nfunction getNextMove(config: BoardConfig): Array<BoardConfig> {\n  const nextMove: Array<BoardConfig> = [];\n  for (const dir of directions) {\n    const nx = config[0].x + dir[0],\n      ny = config[0].y + dir[1];\n    if (nx >= 0 && nx < 3 && ny >= 0 && ny < 3) {\n      const newConfig = config.map((coordinate, index) => {\n        if (index === 0) {\n          return { x: nx, y: ny };\n        }\n        if (coordinate.x === nx && coordinate.y === ny) {\n          return { x: nx - dir[0], y: ny - dir[1] };\n        }\n        return coordinate;\n      });\n      nextMove.push(newConfig);\n    }\n  }\n  return nextMove;\n}\n\nconst bfs: SolveFn = async () => {\n  const begTime = new Date().getTime();\n  const solution: SolutionPath = [];\n\n  const solutionVisitSet = new std.HashSet<BoardConfig>(configHasher, isConfigEql);\n  const preSolution = new std.HashMap<BoardConfig, BoardConfig>(configHasher, isConfigEql);\n  const solutionQueue = new std.Queue<BoardConfig>();\n  solutionVisitSet.push(targetConfig);\n  solutionQueue.push(targetConfig);\n\n  let solved = false;\n  while (!solved && !solutionQueue.empty()) {\n    const front = solutionQueue.front();\n    solutionQueue.pop();\n    for (const config of getNextMove(front)) {\n      if (!solutionVisitSet.count(config)) {\n        solutionVisitSet.push(config);\n        preSolution.push({ first: config, second: front });\n        if (isConfigEql(config, initialConfig)) {\n          solved = true;\n          break;\n        }\n        solutionQueue.push(config);\n      }\n    }\n  }\n\n  if (!solved) {\n    return {\n      time: new Date().getTime() - begTime,\n    };\n  }\n\n  let curConfig = initialConfig;\n  solution.push(curConfig);\n  while (!isConfigEql(curConfig, targetConfig)) {\n    curConfig = preSolution.find(curConfig).second;\n    solution.push(curConfig);\n  }\n\n  return {\n    time: new Date().getTime() - begTime,\n    solution,\n  };\n};\n\nconst dfs: SolveFn = async () => {\n  const begTime = new Date().getTime();\n  const solution: SolutionPath = Array.of(initialConfig);\n  const solutionVisitSet = new std.HashSet<BoardConfig>(configHasher, isConfigEql);\n\n  solutionVisitSet.push(initialConfig);\n  solution.push(initialConfig);\n\n  const innerDfs = (curConfig: BoardConfig): boolean => {\n    if (isConfigEql(curConfig, targetConfig)) {\n      return true;\n    }\n    // prevent overflow of stack\n    if (solution.length >= 200) {\n      return false;\n    }\n    for (const config of getNextMove(curConfig)) {\n      if (!solutionVisitSet.count(config)) {\n        solution.push(config);\n        solutionVisitSet.push(config);\n        if (innerDfs(config)) {\n          return true;\n        }\n        solution.pop();\n      }\n    }\n\n    return false;\n  };\n\n  if (innerDfs(initialConfig)) {\n    return {\n      time: new Date().getTime() - begTime,\n      solution,\n    };\n  }\n\n  return {\n    time: new Date().getTime() - begTime,\n  };\n};\n\nfunction estimateCost(config: BoardConfig, target: BoardConfig): number {\n  let res = 0;\n  for (let i = 1; i < config.length; ++i) {\n    res += Math.abs(config[i].x - target[i].x) + Math.abs(config[i].y - target[i].y);\n  }\n  return res;\n}\n\nconst bestFirst: SolveFn = async () => {\n  const begTime = new Date().getTime();\n  const solution: SolutionPath = Array.of(initialConfig);\n  const solutionVisitSet = new std.HashSet<BoardConfig>(configHasher, isConfigEql);\n\n  solutionVisitSet.push(initialConfig);\n  solution.push(initialConfig);\n\n  const innerDfs = (curConfig: BoardConfig): boolean => {\n    if (isConfigEql(curConfig, targetConfig)) {\n      return true;\n    }\n    for (const config of getNextMove(curConfig).sort(\n      (a, b) => estimateCost(a, targetConfig) - estimateCost(b, targetConfig)\n    )) {\n      if (!solutionVisitSet.count(config)) {\n        solution.push(config);\n        solutionVisitSet.push(config);\n        if (innerDfs(config)) {\n          return true;\n        }\n        solution.pop();\n      }\n    }\n\n    return false;\n  };\n\n  if (innerDfs(initialConfig)) {\n    return {\n      time: new Date().getTime() - begTime,\n      solution,\n    };\n  }\n\n  return {\n    time: new Date().getTime() - begTime,\n  };\n};\n\nconst branchAndBound: SolveFn = async () => {\n  const begTime = new Date().getTime();\n  const solution: SolutionPath = [];\n\n  interface ConfigWithVal {\n    config: BoardConfig;\n    g: number;\n    f: number;\n  }\n  const solutionQueue = new std.PriorityQueue<ConfigWithVal>((a, b) => a.f > b.f);\n  const preSolution = new std.HashMap<ConfigWithVal, ConfigWithVal>();\n\n  const initialConfigWithVal: ConfigWithVal = {\n    config: targetConfig,\n    g: 0,\n    f: estimateCost(targetConfig, initialConfig),\n  };\n  solutionQueue.push(initialConfigWithVal);\n\n  let solved = false;\n  while (!solved && !solutionQueue.empty()) {\n    const top = solutionQueue.top();\n    solutionQueue.pop();\n    for (const config of getNextMove(top.config)) {\n      const newConfigWithVal = {\n        config,\n        g: top.g + 1,\n        f: top.g + 1 + estimateCost(config, initialConfig),\n      };\n      preSolution.push({ first: newConfigWithVal, second: top });\n      if (isConfigEql(config, initialConfig)) {\n        solved = true;\n\n        let curConfig = newConfigWithVal;\n        solution.push(initialConfig);\n        while (!isConfigEql(curConfig.config, targetConfig)) {\n          curConfig = preSolution.find(curConfig).second;\n          solution.push(curConfig.config);\n        }\n        break;\n      }\n      solutionQueue.push(newConfigWithVal);\n    }\n  }\n\n  if (!solved) {\n    return {\n      time: new Date().getTime() - begTime,\n    };\n  }\n\n  return {\n    time: new Date().getTime() - begTime,\n    solution,\n  };\n};\n\nexport const solveFns: Record<Mode, SolveFn> = {\n  bfs: bfs,\n  dfs: dfs,\n  bestfs: bestFirst,\n  bab: branchAndBound,\n};\n","import React, { useEffect, useState } from \"react\";\nimport \"./Board.css\";\nimport { initialConfig } from \"./solve\";\nimport type { BoardConfig, SolutionPath } from \"./types\";\n\nexport function useBoardAnim(\n  boardAnimInterval: number,\n  solution: SolutionPath\n): {\n  boardConfig: BoardConfig;\n  setBoardConfig: React.Dispatch<React.SetStateAction<BoardConfig>>;\n} {\n  const [boardConfig, setBoardConfig] = useState<BoardConfig>(initialConfig);\n\n  useEffect(() => {\n    let configIndex = 0;\n    const interval = setInterval(() => {\n      if (configIndex === solution.length) {\n        clearInterval(interval);\n        return;\n      }\n      setBoardConfig(solution[configIndex++]);\n    }, boardAnimInterval);\n\n    return () => {\n      clearInterval(interval);\n    };\n  }, [boardAnimInterval, solution]);\n\n  return { boardConfig, setBoardConfig };\n}\n\nexport interface BoardProps {\n  boardAnimInterval: number;\n  boardConfig: BoardConfig;\n}\n\nconst tileSize = 50;\n\nexport default function Board({ boardAnimInterval, boardConfig }: BoardProps) {\n  return (\n    <div\n      className=\"board\"\n      style={{\n        [\"--tile-size\" as any]: `${tileSize}px`,\n        [\"--interval\" as any]: `${boardAnimInterval}ms`,\n        width: tileSize * 3,\n        height: tileSize * 3,\n      }}\n    >\n      {boardConfig.map((config, index) => (\n        <div\n          className=\"tile\"\n          style={{\n            [\"--x\" as any]: `${config.x * tileSize}px`,\n            [\"--y\" as any]: `${config.y * tileSize}px`,\n            width: tileSize,\n            height: tileSize,\n          }}\n        >\n          {index > 0 ? index : undefined}\n        </div>\n      ))}\n    </div>\n  );\n}\n","import React from \"react\";\nimport type { Mode } from \"./types\";\n\ninterface ModeSelectProps {\n  mode: Mode;\n  onModeChange: React.ChangeEventHandler<HTMLInputElement>;\n}\n\nexport function ModeSelect({ mode, onModeChange }: ModeSelectProps) {\n  return (\n    <div className=\"radio-group\" onChange={onModeChange}>\n      {[\n        [\"bfs\", \"BFS\"],\n        [\"dfs\", \"DFS\"],\n        [\"bestfs\", \"Best first search\"],\n        [\"bab\", \"Branch and bound\"],\n      ].map((radioInfo) => (\n        <div>\n          <input\n            type=\"radio\"\n            checked={mode === radioInfo[0]}\n            name=\"mode\"\n            value={radioInfo[0]}\n            id={radioInfo[0]}\n          />\n          <label htmlFor={radioInfo[0]}>{radioInfo[1]}</label>\n        </div>\n      ))}\n    </div>\n  );\n}\n","import { useState } from \"react\";\nimport \"./App.css\";\nimport Board, { useBoardAnim } from \"./Board\";\nimport { ModeSelect } from \"./ModeSelect\";\nimport { initialConfig, solveFns } from \"./solve\";\nimport type { Mode, SolutionPath } from \"./types\";\n\ninterface AppProps {\n  boardAnimInterval?: number;\n}\n\nexport default function App(props: AppProps) {\n  const { boardAnimInterval = 300 } = props;\n  const [solution, setSolution] = useState<SolutionPath>([]);\n  const [mode, setMode] = useState<Mode>(\"bfs\");\n\n  const [timeCost, setTimeCost] = useState<number>(NaN);\n  const [msg, setMsg] = useState(\"Solution\");\n\n  const { boardConfig, setBoardConfig } = useBoardAnim(boardAnimInterval, solution);\n\n  return (\n    <div className=\"8-puzzle-app\">\n      <header><h2>Solution for 8-Puzzle problem</h2></header>\n      <div className=\"grid\">\n        <div className=\"grid-left\">\n          <Board boardConfig={boardConfig} boardAnimInterval={boardAnimInterval} />\n          <div className=\"btn-group\">\n            <button\n              onClick={() => {\n                setBoardConfig(initialConfig);\n              }}\n            >\n              Initialization\n            </button>\n            <button\n              onClick={async () => {\n                const { time, solution } = await solveFns[mode]();\n                setTimeCost(time);\n                solution ? setSolution(solution) : setMsg(\"Solution not found\");\n              }}\n            >\n              Run\n            </button>\n          </div>\n        </div>\n        <div className=\"grid-right\">\n          <ModeSelect\n            mode={mode}\n            onModeChange={(e) => {\n              setMode(e.target.value as Mode);\n            }}\n          />\n          <h4>{msg}</h4>\n          <div>Time(s): {timeCost / 1000}</div>\n          <div>Step: {solution.length}</div>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}